\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{color}
\usepackage{boxedminipage}

\lstset{%,
  basicstyle=\small\ttfamily,
  keywordstyle=\color{red},
  identifierstyle=\color{Blue},
  stringstyle=\color{OliveGreen},
  showstringspaces=false,
  language=Python}%,
%  basicstyle=\small\texttt}


\newcommand{\exercise}[1]{
  \bigskip
  \begin{boxedminipage}[c]{0.8\linewidth}
  #1
  \end{boxedminipage}
  \bigskip
}

\newcommand{\dee}[0]{\mathrm d}
\newcommand{\idee}[0]{\,\dee}
\newcommand{\diff}[2]{\frac{\dee #1}{\dee #2}}
\newcommand{\pdiff}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\Ha}[0]{\mathrm{Ha}}
\newcommand{\XC}[0]{\mathrm{XC}}
\newcommand{\X}[0]{\mathrm{X}}
\newcommand{\LDA}[0]{\mathrm{LDA}}
\newcommand{\ext}[0]{\mathrm{ext}}

\title{Script a simple 1D DFT code in Python}
\author{Ask Hjorth Larsen}

\begin{document}

\section{Towards a simple 1D DFT code}

Our goal is to write our own Kohn--Sham (KS) density functional theory
(DFT) code.

A full-featured DFT code is very complex, so we shall here limit our ambitions
to the simplest possible model that is still interesting:
We will iteratively solve the Kohn--Sham
equations for a harmonic oscillator including electronic kinetic
energy, electrostatic repulsion between the electrons, and the
local density approximation for electronic interactions, ignoring correlation.

This gives us the full Hamiltonian
\begin{align}
\hat H = -\frac12 \diff{^2}{x^2} + v_\Ha(x) + v_{\mathrm X}^{\mathrm{LDA}}(x) + x^2.
\end{align}
Overview: We must be able to calculate the KS wavefunctions, the
density, and each of the potentials required to represent the
Hamiltonian.  We must also represent the Hamiltonian somehow,
including the kinetic operator.  But one thing at a time.

\section{Python}
Python is a dynamically typed language.  Python programs are executed
by the Python interpreter.
There are two main versions:
\texttt{python2} (also called just \texttt{python}) and \texttt{python3}.
Either is fine, but we use \texttt{python3}.
Run the interactive Python interpreter:

\begin{verbatim}
askhl@hagen:~$ python3
Python 3.5.2 (default, Nov 17 2016, 17:05:23)
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print('hello world!')
hello world!
>>> 2+2
4
>>> items = [1, 2, 3, 'hello']
>>> for obj in items:
...     print(obj)
...
1
2
3
hello
>>>
\end{verbatim}

Alternatively we can write code within a text editor:
\begin{lstlisting}
print('hello world!')
\end{lstlisting}
Then save the script as \texttt{hello.py} and run it with
\texttt{python3 hello.py}.

Although we always want to write \emph{scripts},
the interactive interpreter is an excellent tool to play around and test
things before adding them to the script.

Use \lstinline{help(obj)} to see the documentation for any object
(including functions and modules).

\section{Grids}
The simplest possible way to represent a real function $f(x)$,
with $a \le x \le b$, is to
sample it on a uniform real-space grid of points $\{x_i\}$ from $a$ to $b$.
The function is then represented by the vector of values $\{f(x_i)\}$.

Use matplotlib to plot $\sin(x)$ on a suitable grid:

\begin{lstlisting}
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(-5, 5, 200)  # define grid
y = np.sin(x)
plt.plot(x, y)
plt.show()
\end{lstlisting}

\exercise{
How do you approximate the first and second derivatives of a function from
its representation $\{f(x_i)\}$ on the grid?  Verify using matplotlib that your
numerical derivatives are correct.
}

Useful hints:

\begin{itemize}
\item Run \texttt{python3} to start the interactive inter
\item Get help about a function: \texttt{help(np.linspace)}
\item Import Numpy: \texttt{import numpy as np}
\item Make a uniform grid: \texttt{np.linspace}
\item Import Matplotlib: \texttt{import matplotlib.pyplot as plt}
\item Plot something: \texttt{plt.plot}
\end{itemize}

Numpy array examples:
\begin{lstlisting}
array = np.zeros(10)  # new array with 10 zeros
array[3] = 5  # Assign to an element
array[5:8] += 2  # In-place add to several elements
print(array[5])  # Print an element
array2 = 2 * array  # Multiply by 2, creating new array
array *= 2  # Multiply all elements in-place

array2D = np.random.rand(4, 8)  # 4 x 8 random numbers
print(array2D[:, 0])  # Print first row
print(array2D[:, 7])  # Print last row
print(array2D[0, :])  # Print first column
\end{lstlisting}

\section{Free non-interacting electrons}

To get the Kohn--Sham wavefunctions we must diagonalize the
Hamiltonian, i.e., calculate its eigenvectors.  We will establish a matrix
representation of the Hamiltonian starting with the kinetic operator
$\hat T$.

If our grid has $N$ points, then all possible linear operators on that
space are represented by $N\times N$ matrices.  An operator $O$ is
applied to a state $\psi(x)$ by left-multiplying it onto the state:
\texttt{Opsi = np.dot(O, psi)}.

\exercise{
How can we represent the action of the kinetic operator (which
includes a second derivative) as a matrix?  Use the expression
for the second derivative derived earlier.
}

\noindent Now we have a matrix representation of the kinetic operator; this
is the Hamiltonian of non-interacting free particles in a box given by
the size of our grid:
\begin{align}
  \hat H = \hat T = -\frac12 \diff{^2}{x^2}
\end{align}
The Kohn--Sham states and their energies are the eigenvectors and
eigenvalues of that matrix.  The matrix is real and symmetric, so both eigenvalues and eigenvectors are real and we can use
\texttt{np.linalg.eigh}:
\begin{lstlisting}
epsilon_n, psit_gn = np.linalg.eigh(T)
\end{lstlisting}
Above, we use \lstinline{_n} as a hint that the array is indexed by state,
and \lstinline{_gn} means a 2D array indexed first by grid index, then state.

Numpy arrays can be used with arithmetic operators (\texttt +, \texttt -,
\texttt *, \ldots) in combination with numbers and other arrays.

You can 
\begin{lstinline}
array = np.zeros(50)
for g in range(50):
    array[g] = g**2
\end{lstinline}
\texttt{psi[g, n]}.  To get a particular function as a whole vector, use
\texttt{psi[:, n]}.

\exercise{
  Choose a grid and calculate the free-particle energies and wavefunctions.
  What are the eigenvalues?
  Plot the wavefunctions $\psi_n(x)$ with the lowest 5 energies.
}

\section{Harmonic oscillator}
Now we include the external potential $v_{\mathrm{ext}}(x) = x^2$ in the Hamiltonian:
\begin{align}
  \hat H = \hat T = -\frac12 \diff{^2}{x^2} + x^2.
\end{align}
This is the harmonic oscillator for non-interacting particles.
How can you represent $x^2$ as a matrix?


\exercise{
Calculate the Hamiltonian and plot the 5 states with lowest energy,
making sure that your grid is adequate.
}

\section{Density}
Next we need to calculate the electron density.

Each state should be normalized so it integrates to one (having the
capacity to contain one electron):
\begin{align}
  \int |\psi(x)|^2 \idee x = 1.
\end{align}
The normalization from \texttt{np.linalg.eigh} will be different.
How do you calculate an integral over the grid?
Make sure all the states integrate to 1.

Then the electron density in DFT is given by
\begin{align}
  n(x) = \sum_n f_n |\psi_n(x)|^2,
\end{align}
where $f_n$ are the \emph{occupation numbers}.

The electrons will
preferentially occupy those available states with lowest energy.  Each
state fits two electrons (one with spin up, and one with spin down), so
a state can in general be occupied by 0, 1, or 2 electrons.

Let us say that we have 6 electrons.  Then the three lowest states
will have occupation number $f=2$ and all others $f=0$.

Plot the electron density for 6 electrons in the harmonic potential.
Verify that the density integrates to 6 electrons.

\section{Exchange energy}
The exchange (and correlation) energy is a correction to the
electronic energy that approximates the effect of electron interactions.
We consider here only the exchange which is particularly simple in LDA,
the local density approximation:
\begin{align}
  E_\X^\LDA[n] = -\frac 34 \left(\frac 3 \pi\right)^{1/3} \int n^{4/3} \idee x
\end{align}
In the derivation of the Kohn--Sham equations, the potential is defined
as the derivative of the total energy with respect to the density.
The exchange \emph{potential} is therefore given by the derivative
of the exchange energy with respect to the density:
\begin{align}
  v_{\X}^\LDA(x) = \pdiff{E_\X^\LDA[n]}{n(x)} = \left(\frac3 \pi\right)^{1/3}
  n(x)
\end{align}
Calculate the exchange potential and energy from the previously
calculated density.

Write a function which, given a density, returns the exchange energy and potential.


\section{Coulomb potential}
(Optionally you may skip ahead to the next exercise and implement the
self-consistency loop if short of time)

The electrostatic energy or Hartree energy is given by
\begin{align}
  E_{\mathrm{Ha}}^{\mathrm{3D}} = \frac12 \iint \frac{n(\mathbf r)n(\mathbf r')}{|\mathbf r - \mathbf r'|}\idee \mathbf r \idee \mathbf r'.
\end{align}
This expression converges in 3D, but not in 1D.  Hence we cheat and use
a modified, ``softened'' form:
\begin{align}
E_{\mathrm{Ha}} = \frac12 \iint \frac{n(x) n(x')}{\sqrt{(x - x')^2 + 1}}.
\idee x \idee x'
\end{align}
Again, the potential is the derivative of the energy with respect to the
density:
\begin{align}
  v_{\mathrm{Ha}}(x) = \pdiff{E_{\mathrm{Ha}}}{n(x)} =
  \int \frac{n(x)}{\sqrt{(x - x')^2 + 1}} \idee x
\end{align}

Calculate the Coulomb energy of the previous density and plot the
Coulomb potential.

\section{Self-consistency loop}
Write a loop which repeats calculating:
\begin{itemize}
\item Exchange energy and potential from the density (you can start with a
  constant density, e.g. 0)
\item Coulomb energy and potential from the density.
\item The Hamiltonian from kinetic operator, external potential,
  and exchange potential
\item Wavefunctions and their energies from the Hamiltonian
\item Density from the normalized wavefunctions and occupations
\end{itemize}
Iterate as many times as it takes to converge the density.  When the
density does not change anymore, the calculated quantities are
\emph{self-consistent}.

\section{Total energy}
The kinetic energy is:
\begin{align}
  \int \psi^*(x)\left(-\frac12 \diff{}{x^2}\right) \psi(x) \idee x
\end{align}
which can be conveniently rewritten as
\begin{align}
  \sum_n f_n \epsilon_n - \int n(x) v(x) \idee x.
\end{align}
Calculate the kinetic energy and each of the other energy contributions to get the final total energy:
\begin{align}
  E = \sum_n f_n \epsilon_n - \int n(x) v(x) \idee x
  + E_\Ha[n] + E_\X[n] + \int n(x) v_{\mathrm{exc}}(x) \idee x.
\end{align}

The DFT code is now complete!  If you want, you can wrap it all in a
single function whose parameters are the grid, the external potential,
and the number of electrons.  Then it can be easily called to perform
different calculations.

\end{document}
